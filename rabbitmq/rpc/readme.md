# rabbitmq实现rpc

```go
amqp.Publishing{
    ContentType:   "text/plain",
    CorrelationId: corrId,
    ReplyTo:       q.Name,  // 在这里指定callback队列名，也是在这个队列等回复
    Body:          []byte(strconv.Itoa(n)),
})

//AMQP 0-9-1协议预定义了消息附带的14个属性集。除以下属性外，大多数属性很少使用：
//
//persistent：将消息标记为持久性（值为true）或瞬态（false）。
//content_type：用于描述编码的mime类型。例如，对于经常使用的JSON编码，将此属性设置为application/ json是一个好习惯。
//reply_to：常用于命名回调队列
//correlation_id：有助于将RPC响应与请求相关联为什么我们应该忽略回调队列中的未知消息，而不是报错而失败？这是由于服务器端可能出现竞争状况。尽管可能性不大，但RPC服务器可能会在向我们发送答案之后但在发送请求的确认消息之前死亡。如果发生这种情况，重新启动的RPC服务器将再次处理该请求。这就是为什么在客户端上我们必须妥善处理重复的响应，并且理想情况下RPC应该是幂等的。
```

工作流程:

客户端启动时，它将创建一个匿名排他回调队列。
对于RPC请求，客户端发送一条消息，该消息具有两个属性：reply_to（设置为回调队列）和correlation_id（设置为每个请求的唯一值）。
该请求被发送到rpc_queue队列。
RPC工作程序（又名：服务器）正在等待该队列上的请求。当出现请求时，它会完成计算工作并把结果作为消息使用replay_to字段中的队列发回给客户端。
客户端等待回调队列上的数据。出现消息时，它将检查correlation_id属性。如果它与请求中的值匹配，则将响应返回给应用程序。


//TODO 如果没有服务器在运行，客户端应如何反应？
//TODO 客户端是否应该为RPC设置某种超时时间？
//TODO 如果服务器发生故障并引发异常，是否应该将其转发给客户端？
//TODO 在处理之前防止无效的传入消息（例如检查边界，类型）。