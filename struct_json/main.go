package main

import (
	"encoding/json"
	"fmt"

	"github.com/mitchellh/mapstructure"
)

//结构体和json转换
//1.序列化：Go语言中结构体变量转换为json格式的字符串
//2.反序列化：json格式的字符串转换为Go语言中可以识别的结构体或者map变量

type person struct {
	Name string `json:"name"` //因为结构体会传入到Marshal函数中所以字段必须是大写的才可以被别的包调用
	Age  int    `json:"age"`  //``是为了指定转换为对应格式的字段名。json："age"标识转json时该字段显示为age
}

//json与struct的转换
func main1() {
	p1 := person{
		Name: "Bradley",
		Age:  18,
	}
	//序列化
	v, error := json.Marshal(p1)
	if error != nil {
		fmt.Printf("error is %v\n", error)
		return
	}
	fmt.Printf("%#v\n", string(v)) //"{\"name\":\"Bradley\",\"age\":18}"
	//反序列化
	str := `{"name":"coope","age":20}`
	var p2 person
	//因为是传入函数且是修改  所以需要传入的是指针;Unmarshal对应的结构体字段首字母必须都是大写的
	json.Unmarshal([]byte(str), &p2)
	fmt.Printf("%#v\n", p2) //main.person{Name:"coope", Age:20}
}

type Person3 struct {
	name   string
	age    int8
	dreams []string
}

func (p *Person3) SetDreams1(dreams []string) {
	p.dreams = dreams
}
func (p *Person3) SetDreams2(dreams []string) {
	p.dreams = make([]string, len(dreams))
	p.dreams = dreams
}
func SetDreams(dreams []string) {
	dreams[0] = "dreams"
}
func main2() {
	//p1 := Person{name: "小王子", age: 18}
	data := []string{"吃饭", "睡觉", "打豆豆"}
	//p1.SetDreams1(data)
	//fmt.Println(p1)
	SetDreams(data)
	//data[1]="bu"
	fmt.Println(data) //slice是引用类型 ，所以会被修改
}

//json与map的转换
func main3() {
	jsonStr := `
		{
			"resultcode": "200",
			"reason": "Return Successd!",
			"result": {
				"province": "浙江",
				"city": "杭州",
				"areacode": "0571",
				"zip": "310000",
				"company": "中国移动",
				"card": ""
			}
		}
	`
	//json转map
	/*
		json转map的缺点：
		通过 key 获取数据，可能出现不存在的 key，为了严谨，需要检查 key 是否存在；
		相对于结构体的方式，map数据提取不便且不能利用 IDE 补全检查，key 容易写错；
	*/

	var p1 map[string]interface{}
	err := json.Unmarshal([]byte(jsonStr), &p1)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println(p1)
	//map[reason:Return Successd! result:map[areacode:0571 card: city:杭州 company:中国移动 province:浙江 zip:310000] resultcode:200]

	//map转json
	p := make(map[string]interface{})
	p["resultcode"] = 200
	p["reason"] = "Return Successd!"
	marshal, err := json.Marshal(p)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println(string(marshal)) //{"reason":"Return Successd!","resultcode":200}

}

//strut与map互转

func main5() {
	//map转struct  需要使用mapstructure包
	//往往在实际使用中我们是拿到一个json格式的字符串，想要解析成struct首先是不知道这个json中具体的
	//字段的，（可以借助第三方工具比如https://mholt.github.io/json-to-go根据json字符转换为struct,
	//但是可能json字段不是固定的）
	//所以要先将其转换为map后，再转换为struct
	p := make(map[string]interface{})
	p["rc"] = 200
	p["rs"] = "Return Successd!"
	in := struct {
		Resultcode int    `mapstructure:"rc"`
		Reason     string `mapstructure:"rs"`
	}{}
	_ = mapstructure.Decode(p, &in)
	fmt.Println(in) //{200 Return Successd!}

	//struct转map；可以先将struct序列化后再将其反序列化到map中；也可以通过反射实现转换
	type User struct {
		Id       int    `json:"id"`
		Username string `json:"username"`
		Password string `json:"password"`
	}
	user := User{5, "zhangsan", "password"}
	marshal, _ := json.Marshal(user)
	var pp map[string]interface{}
	_ = json.Unmarshal([]byte(marshal), &pp)
	fmt.Println(pp)
}

type AutoGenerated struct {
	Type     string `json:"type"`
	Database string `json:"database"`
	Table    string `json:"table"`
	Data     []struct {
		BlogID  int    `json:"blogId"`
		Title   string `json:"title"`
		Content string `json:"content"`
		UID     int    `json:"uid"`
		State   int    `json:"state"`
	} `json:"data"`
}

func main6() {
	jsonStr := `{
    "type": "UPDATE",
    "database": "blog",
    "table": "blog",
    "data": [
        {
            "blogId": "100001",
            "title": "title",
            "content": "this is a blog",
            "uid": "1000012",
            "state": "1"
        }
    ]
}`
	//var m AutoGenerated
	//_ = json.Unmarshal([]byte(jsonStr), &m)
	//fmt.Println(m)

	m1 := make(map[string]interface{})
	json.Unmarshal([]byte(jsonStr), &m1)
	fmt.Println(m1)
	var output AutoGenerated
	//mapstructure.Decode(m1,&output)
	//fmt.Println(output)  //{UPDATE blog blog [{0 title this is a blog 0 0}]}  //int类型没有解析
	mapstructure.WeakDecode(m1, &output)
	fmt.Println(output) //{UPDATE blog blog [{100001 title this is a blog 1000012 1}]} 弱类型解析
}

type person2 struct {
	Name string `mapstructure:"name2"`
	Age  int    `mapstructure:"age2"`
}

func main8() {
	jsonStr := `
	{
	"name2":"wzb",
	"age2":"12"
}
`
	m := make(map[string]interface{})
	json.Unmarshal([]byte(jsonStr), &m)
	fmt.Println(m)
	var p person2
	mapstructure.WeakDecode(m, &p)
	fmt.Println(p)
}

//解决data中参数不确定的方法
type Family struct {
	LastName string `mapstructure:"Ln"`
}
type Location struct {
	City string
}
type Person struct {
	Family    `mapstructure:",squash"`
	Location  `mapstructure:",squash"`
	FirstName string
}

func main() {
	input := map[string]interface{}{
		"FirstName": "Mitchell",
		"Ln":        "Hashimoto",
		"City":      "San Francisco",
	}

	var result Person
	err := mapstructure.Decode(input, &result)
	if err != nil {
		panic(err)
	}
	fmt.Println(result.FirstName)
	fmt.Println(result.LastName)
	fmt.Println(result.City)

}
